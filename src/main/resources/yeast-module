' 0.01 %
Const IDY_PRECISION As Double = 0.0001
' 0.06 hrs = 3.6 min
Const TIME_PRECISION As Double = 0.06


' http://www.fao.org/3/a-ap815e.pdf
' Maximum volume expansion ratio
Const MAX_VOLUME_EXPANSION As Double = 2.87
' Volume factor after each kneading, corresponding to a new stage (V_i = V_i-1 * (1 - VOLUME_REDUCTION)) [%]
Const VOLUME_REDUCTION As Double = 1 - 0.4187


' [%]
Private Function getTargetVolume(params As LeaveningParameters) As Double
    Dim doughVolume As Double: doughVolume = calculateDoughVolume(params)
    Dim minimumHeight As Double: minimumHeight = doughVolume / params.targetArea
    ' FIXME
    getTargetVolume = 0.98 * (params.targetHeight - minimumHeight) / (2.5 - minimumHeight)
    '1.41687 = 3.3
    '0.98 = 2.5

    'targetVolume = params.targetHeight * 0.98 / (2.5 - minimumHeight) - 0.98 * minimumHeight / (2.5 - minimumHeight)

'TODO account for baking temperature
'initialTemperature is somewhat between params.temperature(UBound(params.temperature)) and params.ambientTemperature
'volumeExpansion= calculateCharlesGayLussacVolumeExpansion(initialTemperature, params.bakingTemperature)
End Function


Public Sub calculateIDY(params As LeaveningParameters)
    Dim index As Integer
    Dim size As Integer: size = UBound(params.temperature)
    Dim T As Double: T = params.leaveningTime(0)

    Dim finalVolume As Double: finalVolume = 0
    ReDim params.volume(size - LBound(params.temperature))
    For index = LBound(params.temperature) To size
        If params.leaveningTime(index) > 0 Then
            If index > 0 And params.idy > 0 Then
                ' save value for subsequent restore after `calculateLeaveningTime` changed it
                T = params.leaveningTime(index)

                Call calculateLeaveningTime(params, index)

                ' prepare for next iteration
                params.leaveningTime(index) = params.leaveningTime(index) + T
            End If

            Dim volume As Double: volume = calculateIDYSingle(params, index)

            ' account for volume reduction caused by re-kneading
            If index < size Then
                finalVolume = finalVolume - volume * VOLUME_REDUCTION
            Else
                params.finalVolumeRatio = MAX_VOLUME_EXPANSION * (finalVolume + volume)
            End If

            ' restore original value (for `index` > 0)
            params.leaveningTime(index) = T
        End If
    Next index
End Sub

Private Function calculateCharlesGayLussacVolumeExpansion(initialTemperature As Double, finalTemperature As Double) As Double
    calculateCharlesGayLussacVolumeExpansion = (finalTemperature + ABSOLUTE_ZERO) / (initialTemperature + ABSOLUTE_ZERO)
End Function

' http://www.mscampicchio.com/tecal_10.php
' Y. Choi and M.R. Okos (1986) Journal of Food Process and Applications 1(1): 93 â€“ 101
' http://b.web.umkc.edu/beckerb/publications/journals/thermophysical.pdf
Private Function estimateSpecificHeat(protein As Double, fat As Double, carbohydrate As Double, fiber As Double, ash As Double, temperature As Double) As Double
    Dim cp_protein As Double: cp_protein = 2.0082 + (1.2089 - 0.0013129 * temperature) * temperature
    Dim cp_fat As Double: cp_fat = 1.9842 + (1.4733 - 0.0048008 * temperature) * temperature
    Dim cp_carbohydrate As Double: cp_carbohydrate = 1.5488 + (1.9625 - 0.0059399 * temperature) * temperature
    Dim cp_fiber As Double: cp_fiber = 1.8459 + (1.8306 - 0.0046509 * temperature) * temperature
    Dim cp_ash As Double: cp_ash = 1.0926 + (1.8896 - 0.0036817 * temperature) * temperature

    ' Cp [kJ/(kg * K)]
    estimateSpecificHeat = (cp_protein * protein + cp_fat * fat + cp_carbohydrate * carbohydrate + cp_fiber * fiber + cp_ash * ash) / 100
End Function

' Use bisection method to calculate the yeast able to generate a given final volume after a given time
Private Function calculateIDYSingle(params As LeaveningParameters, index As Integer) As Double
    Dim idy_min As Double
    Dim idy_max As Double: idy_max = 0

    calculateIDYSingle = 0
    params.idy = idy_min
    Dim f_min As Double: f_min = doughVolumeForStage(params, index)
    Dim f_max As Double
    Dim f_max_previous As Double: f_max_previous = f_min
    Do
        idy_min = idy_max
        idy_max = idy_max + 0.025

        params.idy = idy_max
        f_max = doughVolumeForStage(params, index)

        If Abs(f_max - f_max_previous) < 0.0001 Then
            Err.Raise vbObjectError + 513, "PizzaProject.YeastModule", "Cannot reach desired target volume"
        End If
        f_max_previous = f_max
    ' continue until the function seems to change sign in the interval
    Loop While Not changedSign(f_min, f_max, params.targetVolume)

    While idy_max - idy_min > IDY_PRECISION
        params.idy = (idy_min + idy_max) / 2
        f_max = doughVolumeForStage(params, index)
        If changedSign(f_min, f_max, params.targetVolume) Then
            idy_max = params.idy
        Else
            idy_min = params.idy
            f_min = f_max
        End If
    Wend
    calculateIDYSingle = (idy_min + idy_max) / 2
End Function

' Use bisection method to calculate the time necessary to reach a given final volume using a given yeast quantity
Private Sub calculateLeaveningTime(params As LeaveningParameters, index As Integer)
    Dim leaveningTimeMin As Double
    Dim leaveningTimeMax As Double: leaveningTimeMax = 0

    params.leaveningTime(index) = leaveningTimeMax
    Dim f_min As Double: f_min = doughVolumeForStage(params, index)
    Dim f_max As Double
    Do
        leaveningTimeMin = leaveningTimeMax
        leaveningTimeMax = leaveningTimeMax + 2

        params.leaveningTime(index) = leaveningTimeMax
        f_max = doughVolumeForStage(params, index)
    ' continue until the function seems to change sign in the interval
    Loop While Not changedSign(f_min, f_max, params.targetVolume)

    While leaveningTimeMax - leaveningTimeMin > TIME_PRECISION
        params.leaveningTime(index) = (leaveningTimeMin + leaveningTimeMax) / 2
        f_max = doughVolumeForStage(params, index)
        If changedSign(f_min, f_max, params.targetVolume) Then
            leaveningTimeMax = params.leaveningTime(index)
        Else
            leaveningTimeMin = params.leaveningTime(index)
            f_min = f_max
        End If
    Wend
End Sub

' TODO? use density function `0.135+(1.187-0.135)/(1+(time[min]/20.8)^1.82)`
' Calculate volume in percent over maximum volume
' Shafaghat, Najafpour, Rezaei, Sharifzadeh. Optimal growth of Saccharomyces cerevisiaea on pretreated molasses for the ethanol production. 2010. (http://www.doiserbia.nb.rs/img/doi/1451-9372/2010/1451-93721000029S.pdf)
' Romano, Toraldo, Cavella, Masi. Description of leavening of bread dough with mathematical modelling. 2007. (https://mohagheghsho.ir/wp-content/uploads/2020/01/Description-of-leavening-of-bread.pdf)
Public Function doughVolumeForStage(params As LeaveningParameters, index As Integer) As Double
    If params.idy = 0 Or params.leaveningTime(index) = 0 Then
        ' no yeast or no leavening time implies no expansion
        doughVolumeForStage = 0
    Else
        ' maximum relative volume expansion ratio (Vmax)
        Dim alpha As Double: alpha = IIf(params.idy < 0.011, 1 + (297.6 - 10694 * params.idy) * params.idy, MAX_VOLUME_EXPANSION)
        ' lag time [hrs]
        Dim t_lag As Double: t_lag = getEstimatedLag(params.idy)
        Dim mu As Double: mu = calculateMu(params, index)

        Dim leaveningTime As Double: leaveningTime = params.leaveningTime(index)
        ' [%]
        doughVolumeForStage = alpha * f(leaveningTime, mu, t_lag, alpha)
    End If
End Function

' UNUSED
' Calculate area under the curve using Romberg's method
' https://github.com/jrvarma/MSExcel-Numerical-Integration/blob/master/QuadratureForm.frm
' http://www.namirshammas.com/NEW/Romberg.pdf
Private Function gasProductionForStage(params As LeaveningParameters, index As Integer, Optional eps As Double = 0.00000001) As Double
    If params.idy = 0 Or params.leaveningTime(index) = 0 Then
        ' no yeast or no leavening time implies no expansion
        gasProductionForStage = 0
    Else
        ' maximum relative volume expansion ratio (Vmax)
        Dim alpha As Double: alpha = 10 * IIf(params.idy < 0.011, 1 + (297.6 - 10694 * params.idy) * params.idy, MAX_VOLUME_EXPANSION)
        ' lag time [hrs]
        Dim t_lag As Double: t_lag = getEstimatedLag(params.idy)
        Dim mu As Double: mu = calculateMu(params, index)


        ' a and b are the limits of integration
        ' f is the function to be integrated (see function definition at the top)
        ' Trapezoidal rule with 2^k subintervals of length (a-b)/2^k is
        ' T(k) = h[f(a)/2 + f(a+h) + f(a+2h) + ... + f(b)/2]
        ' This can be computed more easily using the recursive definition
        ' T(k) = [T(k-1) + M(k-1)]/2 where M(k) denotes the mid-point rule
        ' Consider the triangular array
        ' T(0,0)
        ' T(1,0)    T(0,1)
        ' T(2,0)    T(1,1)  T(0,2)
        '   ...
        ' where T(k,0) denotes T(k) and
        ' T(k,m) = [4^m T(k+1,m-1) - T(k,m-1)]/(4^m-1)
        ' The successive Romberg approximants are the diagonal elements of this array
        Dim eta As Double: eta = 0.00000001

        Dim n As Integer, i As Integer, j As Integer, g As Long
        Dim a As Double: a = 0
        Dim b As Double: b = params.leaveningTime(index)
        Dim h As Double: h = b - a
        ' t = T(0,0)
        Dim T As Double: T = h * (f(a, mu, t_lag, alpha) + f(b, mu, t_lag, alpha)) / 2
        Dim x As Double, sum As Double
        Dim q(1 To 100) As Double, qx1 As Double, qx2 As Double

        Dim nx As Integer: nx = 1
        Dim convergedAbs As Boolean, convergedRel As Boolean
        For n = 1 To 33
            ' compute new step size
            h = h / 2

            ' compute trapezoid rule approximation
            sum = 0
            For i = 1 To nx
                sum = sum + f(a + (2 * i - 1) * h, mu, t_lag, alpha)
            Next i

            ' 2h*sum is M(n-1) and we compute T(n) from T(n-1) and M(n-1)
            T = T / 2 + h * sum
            ' compute q(n) = T(n-1,1)
            q(n) = 2 * (T + h * sum) / 3

            If (n >= 2) Then
                ' get Romberg improvements
                g = 4
                For j = 2 To n
                    i = n + 1 - j
                    g = g * 4
                    ' at the end of each iteration:
                    '   q is the n'th row of the T array in reverse order with the element T(n,0) omitted
                    '   q(1) = T(0,n)
                    '   q(n) = T(n-1,1) and the elements in between are T(1,n-1), T(2,n-2), T(3,n-3) ...
                    ' compute now the new q array using the previous q array proceeding from q(n) to q(1)
                    q(i) = q(i + 1) + (q(i + 1) - q(i)) / (g - 1)
                Next j
            End If
            If (n >= 3) Then
                ' for convergence tests, compute the differences between the q(1) values from the last three iterations
                x = Abs(q(1) - qx2) + Abs(qx2 - qx1)
                ' absolute error test : |q(1)-I| < eps where I is the true integral
                convergedAbs = x <= 3 * eps
                ' relative error test : |q(1)-I|/|I| < eta or more precisely
                '   q(1) = integral of (1+y(x))f(x)dx where |y(x)| < eta
                ' this is relative error only if f(x) does not change sign
                convergedRel = (T <> 0 And (x <= T * 3 * eta))
                gasProductionForStage = q(1)

                ' check convergence
                If ((n >= Min) And (convergedAbs Or convergedRel)) Then
                    Exit For
                End If
            End If

            ' store the q(1) values of last two iterations
            If (n >= 2) Then
                qx1 = qx2
                qx2 = q(1)
            End If

            nx = nx * 2
        Next n
        If Not (convergedAbs Or convergedRel) Then
            gasProductionForStage = -1
        End If
    End If
End Function
